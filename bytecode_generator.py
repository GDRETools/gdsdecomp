import os
from pathlib import Path
import json

PRELUDE = """// This file is automatically generated by `bytecode_generator.py`
// Do not edit this file directly, as it will be overwritten.
// Instead, edit `bytecode_generator.py` and run it to generate this file.\n"""

CLANG_FORMAT_OFF = """\n// clang-format off\n"""

# TODO: Move this into the JSON file
builtin_func_arg_elements = [
    ("sin", (1, 1)),
    ("cos", (1, 1)),
    ("tan", (1, 1)),
    ("sinh", (1, 1)),
    ("cosh", (1, 1)),
    ("tanh", (1, 1)),
    ("asin", (1, 1)),
    ("acos", (1, 1)),
    ("atan", (1, 1)),
    ("atan2", (2, 2)),
    ("sqrt", (1, 1)),
    ("fmod", (2, 2)),
    ("fposmod", (2, 2)),
    ("posmod", (2, 2)),
    ("floor", (1, 1)),
    ("ceil", (1, 1)),
    ("round", (1, 1)),
    ("abs", (1, 1)),
    ("sign", (1, 1)),
    ("pow", (2, 2)),
    ("log", (1, 1)),
    ("exp", (1, 1)),
    ("is_nan", (1, 1)),
    ("is_inf", (1, 1)),
    ("is_equal_approx", (2, 2)),
    ("is_zero_approx", (1, 1)),
    ("ease", (2, 2)),
    ("decimals", (1, 1)),
    ("step_decimals", (1, 1)),
    ("stepify", (2, 2)),
    ("lerp", (3, 3)),
    ("lerp_angle", (3, 3)),
    ("inverse_lerp", (3, 3)),
    ("range_lerp", (5, 5)),
    ("smoothstep", (3, 3)),
    ("move_toward", (3, 3)),
    ("dectime", (3, 3)),
    ("randomize", (0, 0)),
    ("randi", (0, 0)),
    ("randf", (0, 0)),
    ("rand_range", (2, 2)),
    ("seed", (1, 1)),
    ("rand_seed", (1, 1)),
    ("deg2rad", (1, 1)),
    ("rad2deg", (1, 1)),
    ("linear2db", (1, 1)),
    ("db2linear", (1, 1)),
    ("polar2cartesian", (2, 2)),
    ("cartesian2polar", (2, 2)),
    ("wrapi", (3, 3)),
    ("wrapf", (3, 3)),
    ("max", (2, 2)),
    ("min", (2, 2)),
    ("clamp", (3, 3)),
    ("nearest_po2", (1, 1)),
    ("weakref", (1, 1)),
    ("funcref", (2, 2)),
    ("convert", (2, 2)),
    ("typeof", (1, 1)),
    ("type_exists", (1, 1)),
    ("char", (1, 1)),
    ("ord", (1, 1)),
    ("str", (1, "INT_MAX")),
    ("print", (0, "INT_MAX")),
    ("printt", (0, "INT_MAX")),
    ("prints", (0, "INT_MAX")),
    ("printerr", (0, "INT_MAX")),
    ("printraw", (0, "INT_MAX")),
    ("print_debug", (0, "INT_MAX")),
    ("push_error", (1, 1)),
    ("push_warning", (1, 1)),
    ("var2str", (1, 1)),
    ("str2var", (1, 1)),
    ("var2bytes", (1, 1)),
    ("bytes2var", (1, 1)),
    ("range", (1, 3)),
    ("load", (1, 1)),
    ("inst2dict", (1, 1)),
    ("dict2inst", (1, 1)),
    ("validate_json", (1, 1)),
    ("parse_json", (1, 1)),
    ("to_json", (1, 1)),
    ("hash", (1, 1)),
    ("Color8", (3, 4)),
    ("ColorN", (1, 2)),
    ("print_stack", (0, 0)),
    ("get_stack", (0, 0)),
    ("instance_from_id", (1, 1)),
    ("len", (1, 1)),
    ("is_instance_valid", (1, 1)),
    ("deep_equal", (2, 2)),
    ("get_inst", (1, 1)),
]

greater_than_3_1_versions = [
    0xF3F05DC,
    0x506DF14,
    0xA7AAD78,
    0x5565F55,
    0x6694C11,
    0xA60F242,
    0xC00427A,
    0x620EC47,
    0x7F7D97F,
    0x514A3FB,
]


class BytecodeClass:
    def __init__(self):
        self.func_names = []
        self.tk_names = []
        self.bytecode_version = 0
        self.bytecode_rev = ""
        self.bytecode_rev_num = 0
        self.engine_ver_major = 0
        self.variant_ver_major = 0
        self.parent = ""
        self.version_string = ""
        self.is_dev = False
        self.removed_tokens: list[str] = []
        self.added_tokens: list[str] = []
        self.removed_functions: list[str] = []
        self.added_functions: list[str] = []
        self.renamed_functions: list[dict] = []
        self.arg_count_changed: list[str] = []
        self.tokens_renamed: list[dict] = []
        self.date = ""
        self.engine_version = ""
        self.max_engine_version = ""

    @property
    def file_stem(self):
        return "bytecode_" + self.bytecode_rev

    @property
    def class_name(self):
        return "GDScriptDecomp_" + self.bytecode_rev


def remove_comments(line: str) -> str:
    line = line.strip()
    if line.startswith("//"):
        return ""
    line = line.split("//")[0].strip()
    return line


# Now, we need to generate the bytecode file
# The cpp file will contain the following:
# 1) the header declarations:
# ```cpp
#
# #include "<file_stem>.h"
# ```
# 2) the builtin function declarations, laid out like this:
# ```cpp
# static const Pair<String, Pair<int, int>> funcs[] = {
# 	{ "sin", Pair<int, int>(1, 1) },
#   { "cos", Pair<int, int>(1, 1) },
#   { "tan", Pair<int, int>(1, 1) },
#   { "sinh", Pair<int, int>(1, 1) },
# 	[etc...]
# 	{ "is_instance_valid", Pair<int, int>(1, 1) },
# };
# static constexpr int num_funcs = sizeof(funcs) / sizeof(Pair<String, Pair<int, int>>);
# ```
# We use a Pair here because we need to store the number of arguments for each function
# we get this by matching the function name with the builtin_func_arg_elements list
# with special care for the "var2bytes" and "bytes2var" functions, which have a variable number of arguments (1-2) IF the bytecode version is > 3.1
# 3) the Token enum declarations, like this:
# ```cpp
# enum Token {
# 	TK_EOF,
# 	TK_IDENTIFIER,
# 	TK_CONSTANT,
# 	[..etc]
#   TK_MAX
# };
# ```
# 4) the `get_function_name` function, which is laid out like this:
# ```cpp
# String <class_name>::get_function_name(int p_func) const {
# 	return funcs[p_func].first;
# }
# ```
# 5) the `get_function_arg_count` function, which is laid out like this:
# ```cpp
# Pair<int, int> <class_name>::get_function_arg_count(int p_func) const {
# 	return funcs[p_func].second;
# }
# ```
# 5.5) the `get_function_index` function, which is laid out like this:
# ```cpp
# int <class_name>::get_function_index(const String &p_func) const {
#   for (int i = 0; i < num_funcs; i++) {
#     if (funcs[i].first == p_func) {
#       return i;
#     }
#   return -1;
# }
# ```
# 6) the `get_global_token` function, which is laid out like this:
# ```cpp
# GDScriptDecomp::GlobalToken <class_name>::get_global_token(int p_token) const {
# 	if (p_token < 0 || p_token >= TK_MAX) {
# 		return GDScriptDecomp::GlobalToken::G_TK_MAX;
# 	}
# 	switch(Token(p_token)) {
# 		case TK_EOF: return GDScriptDecomp::GlobalToken::G_TK_EOF;
# 		case TK_IDENTIFIER: return GDScriptDecomp::GlobalToken::G_TK_IDENTIFIER;
# 		case TK_CONSTANT: return GDScriptDecomp::GlobalToken::G_TK_CONSTANT;
# 		[..etc]
# 		case TK_MAX: return GDScriptDecomp::GlobalToken::G_TK_MAX;
# 	}
# 	return GDScriptDecomp::GlobalToken::G_TK_MAX;
# }
# ```
# 7) the `get_local_token_val` function, which is laid out like this:
# ```cpp
# int <class_name>::get_local_token_val(GDScriptDecomp::GlobalToken p_token) const {
#   switch(p_token) {
#     case GDScriptDecomp::GlobalToken::G_TK_EOF: return (int) TK_EOF;
#     case GDScriptDecomp::GlobalToken::G_TK_IDENTIFIER: return (int) TK_IDENTIFIER;
#     case GDScriptDecomp::GlobalToken::G_TK_CONSTANT: return (int) TK_CONSTANT;
#     [..etc]
#     case GDScriptDecomp::GlobalToken::G_TK_MAX: return (int) TK_MAX;
#     default: return (int) TK_MAX;
#   }
#   return (int) TK_MAX;
# }
# ```
# That's it. We're done.


NO_BUILTIN_FUNCTION_BODY = """
String {0}::get_function_name(int p_func) const {{
    return "";
}}
int {0}::get_function_count() const {{
    return 0;
}}
Pair<int, int> {0}::get_function_arg_count(int p_func) const {{
    return Pair<int, int>(-1, -1);
}}
int {0}::get_function_index(const String &p_func) const {{
    return -1;
}}
"""


def generate_class_cpp(dir: Path, bytecode_class: BytecodeClass) -> None:
    file_stem = bytecode_class.file_stem
    class_name = bytecode_class.class_name
    func_names = bytecode_class.func_names
    tk_names = bytecode_class.tk_names
    bytecode_version = bytecode_class.bytecode_version
    bytecode_rev = bytecode_class.bytecode_rev
    bytecode_rev_num = bytecode_class.bytecode_rev_num
    engine_ver_major = bytecode_class.engine_ver_major
    variant_ver_major = bytecode_class.variant_ver_major
    new_dir = dir
    # ensure the directory exists
    if not new_dir.exists():
        new_dir.mkdir()
    new_file_cpp = new_dir / (file_stem + ".cpp")
    with open(new_file_cpp, "w") as f:
        f.write(PRELUDE)
        f.write(CLANG_FORMAT_OFF)
        # 1) the header declarations:
        f.write('#include "' + file_stem + '.h"\n')
        f.write("\n")

        # 2) the builtin function declarations:
        if len(func_names) != 0:
            f.write("static const Pair<String, Pair<int, int>> funcs[] = {\n")
            for func_name in func_names:
                if func_name == "var2bytes" or func_name == "bytes2var":
                    if bytecode_rev_num in greater_than_3_1_versions:
                        f.write('\t{ "' + func_name + '", Pair<int, int>(1, 2) },\n')
                    else:
                        f.write('\t{ "' + func_name + '", Pair<int, int>(1, 1) },\n')
                else:
                    for builtin_func_arg_element in builtin_func_arg_elements:
                        if builtin_func_arg_element[0] == func_name:
                            f.write(
                                '\t{ "'
                                + func_name
                                + '", Pair<int, int>('
                                + str(builtin_func_arg_element[1][0])
                                + ", "
                                + str(builtin_func_arg_element[1][1])
                                + ") },\n"
                            )
                            break
            f.write("};\n")
            f.write("\n")
            f.write("static constexpr int num_funcs = sizeof(funcs) / sizeof(Pair<String, Pair<int, int>>);\n")
        # 3) the Token enum declarations:
        f.write("enum Token {\n")
        for tk_name in tk_names:
            f.write("\t" + tk_name + ",\n")
        f.write("};\n")
        f.write("\n")

        # 3.5) the `get_token_max` function:
        f.write("int " + class_name + "::get_token_max() const {\n")
        f.write("\treturn TK_MAX;\n")
        f.write("}\n")

        if len(func_names) == 0:
            f.write(NO_BUILTIN_FUNCTION_BODY.format(class_name))
        else:
            # 4) the `get_function_name` function:
            f.write("String " + class_name + "::get_function_name(int p_func) const {\n")
            f.write("\tif (p_func < 0 || p_func >= num_funcs) {\n")
            f.write('\t\treturn "";\n')
            f.write("\t}\n")
            f.write("\treturn funcs[p_func].first;\n")
            f.write("}\n")
            f.write("\n")

            # 4.5) the `get_function_count` function:
            f.write("int " + class_name + "::get_function_count() const {\n")
            f.write("\treturn num_funcs;\n")
            f.write("}\n")

            # 5) the `get_function_arg_count` function:
            f.write("Pair<int, int> " + class_name + "::get_function_arg_count(int p_func) const {\n")
            f.write("\tif (p_func < 0 || p_func >= num_funcs) {\n")
            f.write("\t\treturn Pair<int, int>(-1, -1);\n")
            f.write("\t}\n")
            f.write("\treturn funcs[p_func].second;\n")
            f.write("}\n")
            f.write("\n")

            f.write("\n")
            # 5.5) the `get_function_index` function:
            f.write("int " + class_name + "::get_function_index(const String &p_func) const {\n")
            f.write("\tfor (int i = 0; i < num_funcs; i++) {\n")
            f.write("\t\tif (funcs[i].first == p_func) {\n")
            f.write("\t\t\treturn i;\n")
            f.write("\t\t}\n")
            f.write("\t}\n")
            f.write("\treturn -1;\n")
            f.write("}\n")
            f.write("\n")

        # 6) the `get_global_token` function:
        f.write("GDScriptDecomp::GlobalToken " + class_name + "::get_global_token(int p_token) const {\n")
        f.write("\tif (p_token < 0 || p_token >= TK_MAX) {\n")
        f.write("\t\treturn GDScriptDecomp::GlobalToken::G_TK_MAX;\n")
        f.write("\t}\n")
        f.write("\tswitch(Token(p_token)) {\n")
        for tk_name in tk_names:
            f.write("\t\tcase " + tk_name + ": return GDScriptDecomp::GlobalToken::G_" + tk_name + ";\n")
        f.write("\t\tdefault: return GDScriptDecomp::GlobalToken::G_TK_MAX;\n")
        f.write("\t}\n")
        f.write("\treturn GDScriptDecomp::GlobalToken::G_TK_MAX;\n")
        f.write("}\n")
        f.write("\n")

        # 7) the `get_local_token_val` function:
        f.write("int " + class_name + "::get_local_token_val(GDScriptDecomp::GlobalToken p_token) const {\n")
        f.write("\tswitch(p_token) {\n")
        for tk_name in tk_names:
            f.write("\t\tcase GDScriptDecomp::GlobalToken::G_" + tk_name + ": return (int) " + tk_name + ";\n")
        f.write("\t\tdefault: return -1;\n")
        f.write("\t}\n")
        f.write("\treturn -1;\n")
        f.write("}\n")
        f.write("\n")

        # 8) the `test_bytecode` function:
        # f.write("GDScriptDecomp::BYTECODE_TEST_RESULT " + class_name + "::test_bytecode(Vector<uint8_t> buffer) {\n")
        # f.write("\treturn GDScriptDecomp::test_bytecode(buffer);\n")
        # f.write("}\n")
        # f.write("\n")


# The class header files will look like this:
# ```cpp
# class <class_name> : public GDScriptDecomp {
# 	GDCLASS(<class_name>, GDScriptDecomp);
# protected:
# 	static void _bind_methods(){};
# 	static constexpr int bytecode_version = <bytecode_version>;
# 	static constexpr int bytecode_rev = <bytecode_rev_num>;
# 	static constexpr int engine_ver_major = <engine_ver_major>;
# 	static constexpr int variant_ver_major = <variant_ver_major>;
# 	static constexpr const char *bytecode_rev_str = "<bytecode_rev_str>";
#   static constexpr const char *engine_version = "<engine_version>";
#   static constexpr const char *max_engine_version = "<max_engine_version>";
#   static constexpr int parent = <parent>;
#
# 	virtual Vector<GlobalToken> get_added_tokens() const { return {<added_tokens>}; }
# 	virtual Vector<GlobalToken> get_removed_tokens() const { return {<removed_tokens>}; }
# 	virtual Vector<String> get_added_functions() const { return {<added_functions>}; }
# 	virtual Vector<String> get_removed_functions() const { return {<removed_functions>}; }
# 	virtual Vector<String> get_function_arg_count_changed() const { return {<arg_count_changed>}; }
#
# public:
# 	virtual String get_function_name(int p_func) const override;
#   virtual int get_token_max() const override;
# 	virtual int get_function_count() const override;
# 	virtual Pair<int, int> get_function_arg_count(int p_func) const override;
#   virtual int get_function_index(const String &p_func) const override;
# 	virtual GDScriptDecomp::GlobalToken get_global_token(int p_token) const override;
# 	virtual int get_local_token_val(GDScriptDecomp::GlobalToken p_token) const override;
# 	virtual BYTECODE_TEST_RESULT test_bytecode(Vector<uint8_t> buffer) override;
# 	virtual int get_bytecode_version() const override { return bytecode_version; }
# 	virtual int get_bytecode_rev() const override { return bytecode_rev; }
# 	virtual int get_engine_ver_major() const override { return engine_ver_major; }
# 	virtual int get_variant_ver_major() const override { return variant_ver_major; }
#   virtual int get_parent() const override { return parent; }
# 	virtual String get_engine_version() const override { return engine_version; }
# 	virtual String get_max_engine_version() const override { return max_engine_version; }


# 	<class_name>() {}
# };
# ```
def generate_class_header(dir: Path, bytecode_class: BytecodeClass) -> None:
    file_stem = bytecode_class.file_stem
    class_name = bytecode_class.class_name
    func_names = bytecode_class.func_names
    tk_names = bytecode_class.tk_names
    bytecode_version = bytecode_class.bytecode_version
    bytecode_rev = bytecode_class.bytecode_rev
    bytecode_rev_num = bytecode_class.bytecode_rev_num
    engine_ver_major = bytecode_class.engine_ver_major
    variant_ver_major = bytecode_class.variant_ver_major
    new_dir = dir
    # ensure the directory exists
    if not new_dir.exists():
        new_dir.mkdir()
    new_file_h = new_dir / (file_stem + ".h")
    new_added_tokens = ["GlobalToken::G_" + tk_name for tk_name in bytecode_class.added_tokens]
    new_removed_tokens = ["GlobalToken::G_" + tk_name for tk_name in bytecode_class.removed_tokens]
    with open(new_file_h, "w") as f:
        f.write(PRELUDE)
        f.write(CLANG_FORMAT_OFF)
        f.write("#pragma once\n")
        f.write("\n")
        f.write('#include "bytecode_base.h"\n')
        f.write("\n")
        f.write("class " + class_name + " : public GDScriptDecomp {\n")
        f.write("\tGDCLASS(" + class_name + ", GDScriptDecomp);\n")
        f.write("protected:\n")
        f.write("\tstatic void _bind_methods(){};\n")
        f.write("\tstatic constexpr int bytecode_version = " + str(bytecode_version) + ";\n")
        f.write("\tstatic constexpr int bytecode_rev = 0x" + bytecode_rev + ";\n")
        f.write("\tstatic constexpr int engine_ver_major = " + str(engine_ver_major) + ";\n")
        f.write("\tstatic constexpr int variant_ver_major = " + str(variant_ver_major) + ";\n")
        f.write('\tstatic constexpr const char *bytecode_rev_str = "' + bytecode_rev + '";\n')
        f.write('\tstatic constexpr const char *engine_version = "' + bytecode_class.engine_version + '";\n')
        f.write('\tstatic constexpr const char *max_engine_version = "' + bytecode_class.max_engine_version + '";\n')
        if bytecode_class.parent != None:
            f.write("\tstatic constexpr int parent = 0x" + str(bytecode_class.parent) + ";\n")
        else:
            f.write("\tstatic constexpr int parent = 0;\n")
        f.write("\n")
        if len(new_added_tokens) > 0:
            f.write(
                "\tvirtual Vector<GlobalToken> get_added_tokens() const override { return {"
                + ", ".join(new_added_tokens)
                + "}; }\n"
            )
        if len(new_removed_tokens) > 0:
            f.write(
                "\tvirtual Vector<GlobalToken> get_removed_tokens() const override { return {"
                + ", ".join(new_removed_tokens)
                + "}; }\n"
            )
        if len(bytecode_class.added_functions) > 0:
            f.write(
                '\tvirtual Vector<String> get_added_functions() const override { return {"'
                + '", "'.join(bytecode_class.added_functions)
                + '"}; }\n'
            )
        if len(bytecode_class.removed_functions) > 0:
            f.write(
                '\tvirtual Vector<String> get_removed_functions() const override { return {"'
                + '", "'.join(bytecode_class.removed_functions)
                + '"}; }\n'
            )
        if len(bytecode_class.arg_count_changed) > 0:
            f.write(
                '\tvirtual Vector<String> get_function_arg_count_changed() const override { return {"'
                + '", "'.join(bytecode_class.arg_count_changed)
                + '"}; }\n'
            )
        f.write("public:\n")
        f.write("\tvirtual String get_function_name(int p_func) const override;\n")
        f.write("\tvirtual int get_function_count() const override;\n")
        f.write("\tvirtual Pair<int, int> get_function_arg_count(int p_func) const override;\n")
        f.write("\tvirtual int get_token_max() const override;\n")
        f.write("\tvirtual int get_function_index(const String &p_func) const override;\n")
        f.write("\tvirtual GDScriptDecomp::GlobalToken get_global_token(int p_token) const override;\n")
        f.write("\tvirtual int get_local_token_val(GDScriptDecomp::GlobalToken p_token) const override;\n")
        f.write("\tvirtual int get_bytecode_version() const override { return bytecode_version; }\n")
        f.write("\tvirtual int get_bytecode_rev() const override { return bytecode_rev; }\n")
        f.write("\tvirtual int get_engine_ver_major() const override { return engine_ver_major; }\n")
        f.write("\tvirtual int get_variant_ver_major() const override { return variant_ver_major; }\n")
        f.write("\tvirtual int get_parent() const override { return parent; }\n")
        f.write("\tvirtual String get_engine_version() const override { return engine_version; }\n")
        f.write("\tvirtual String get_max_engine_version() const override { return max_engine_version; }\n")

        f.write("\t" + class_name + "() {}\n")
        f.write("};\n")
        f.write("\n")


def write_bytecode_json(dir: Path, bytecode_classes: list[BytecodeClass]) -> None:
    bytecode_json = []
    for bytecode_class in bytecode_classes:
        bytecode_json.append(
            {
                "bytecode_rev": bytecode_class.bytecode_rev,
                "bytecode_version": bytecode_class.bytecode_version,
                "date": bytecode_class.date,
                "engine_version": bytecode_class.engine_version,
                "max_engine_version": bytecode_class.max_engine_version,
                "engine_ver_major": bytecode_class.engine_ver_major,
                "variant_ver_major": bytecode_class.variant_ver_major,
                "parent": bytecode_class.parent,
                "is_dev": bytecode_class.is_dev,
                "added_tokens": bytecode_class.added_tokens,
                "removed_tokens": bytecode_class.removed_tokens,
                "added_functions": bytecode_class.added_functions,
                "removed_functions": bytecode_class.removed_functions,
                "renamed_functions": bytecode_class.renamed_functions,
                "arg_count_changed": bytecode_class.arg_count_changed,
                "tokens_renamed": bytecode_class.tokens_renamed,
                "func_names": bytecode_class.func_names,
                "tk_names": bytecode_class.tk_names,
            }
        )
    with open(our_dir / "bytecode_versions.json", "w") as f:
        f.write(json.dumps(bytecode_json, indent=4))


def read_bytecode_json(path: Path) -> list[BytecodeClass]:
    bytecode_json = []
    with open(path, "r") as f:
        bytecode_json = json.loads(f.read())
    bytecode_classes = []
    for bytecode in bytecode_json:
        bytecode_class = BytecodeClass()
        bytecode_class.bytecode_rev = bytecode["bytecode_rev"]
        bytecode_class.bytecode_version = bytecode["bytecode_version"]
        bytecode_class.date = bytecode["date"]
        bytecode_class.engine_version = bytecode["engine_version"]
        bytecode_class.max_engine_version = bytecode["max_engine_version"]
        bytecode_class.engine_ver_major = bytecode["engine_ver_major"]
        bytecode_class.variant_ver_major = bytecode["variant_ver_major"]
        bytecode_class.parent = bytecode["parent"]
        bytecode_class.func_names = bytecode["func_names"]
        bytecode_class.tk_names = bytecode["tk_names"]
        bytecode_class.added_tokens = bytecode["added_tokens"]
        bytecode_class.removed_tokens = bytecode["removed_tokens"]
        bytecode_class.added_functions = bytecode["added_functions"]
        bytecode_class.removed_functions = bytecode["removed_functions"]
        bytecode_class.renamed_functions = bytecode["renamed_functions"]
        bytecode_class.arg_count_changed = bytecode["arg_count_changed"]
        bytecode_class.tokens_renamed = bytecode["tokens_renamed"]
        bytecode_class.is_dev = bytecode["is_dev"]
        bytecode_classes.append(bytecode_class)
    return bytecode_classes


def generate_bytecode_description_string(bytecode_class: BytecodeClass) -> str:
    # examples:
    # f3f05dc would have the description: "removed `SYNC` and `SLAVE` tokens"
    # 506df14 would have the description: "removed `decimals` function"
    # a7aad78 would have the description: "added `deep_equal` function"
    # d6b31da would have the description: "added `PUPPET` token, token `SLAVESYNC` renamed to `PUPPETSYNC`"

    description: str = ""

    def add_to_desc(format_str: str, listarg: list[str]) -> None:
        nonlocal description
        if len(description) > 0:
            description += ", "
        description += format_str.format("`, `".join(listarg))
        if len(listarg) > 1:
            description += "s"

    if len(bytecode_class.added_tokens) > 0:
        # make a new list with all the added_tokens with the prefixes "TK_PR_", "TK_CF_", and "TK_" removed
        new_added_tokens = [
            token.replace("TK_PR_", "").replace("TK_CF_", "").replace("TK_", "")
            for token in bytecode_class.added_tokens
        ]

        add_to_desc("added `{}` token", new_added_tokens)
    if len(bytecode_class.removed_tokens) > 0:
        new_removed_tokens = [
            token.replace("TK_PR_", "").replace("TK_CF_", "").replace("TK_", "")
            for token in bytecode_class.removed_tokens
        ]
        add_to_desc("removed `{}` token", new_removed_tokens)
    if len(bytecode_class.added_functions) > 0:
        add_to_desc("added `{}` function", bytecode_class.added_functions)
    if len(bytecode_class.removed_functions) > 0:
        add_to_desc("removed `{}` function", bytecode_class.removed_functions)
    if len(bytecode_class.arg_count_changed) > 0:
        add_to_desc("changed argument count for `{}` function", bytecode_class.arg_count_changed)
    if len(bytecode_class.renamed_functions) > 0:
        for dict in bytecode_class.renamed_functions:
            dict_key: str = list(dict.keys())[0]
            fmt_insert = "{} to {}".format(dict_key, dict[dict_key])
            add_to_desc("renamed function {}", [fmt_insert])
    if len(bytecode_class.tokens_renamed) > 0:
        for dict in bytecode_class.tokens_renamed:
            dict_key = list(dict.keys())[0]
            fmt_insert = "`{}` to `{}`".format(
                dict_key.replace("TK_PR_", "").replace("TK_CF_", "").replace("TK_", ""),
                dict[dict_key].replace("TK_PR_", "").replace("TK_CF_", "").replace("TK_", ""),
            )
            add_to_desc("renamed token {}", [fmt_insert])
    if len(description) == 0:
        return "initial version"
    return description[0].upper() + description[1:] + "."


# bytecode_versions.h will contain the following
# ```cpp
# #pragma once
#
# #include "bytecode/bytecode_base.h"
#
# <Includes for each bytecode class>
#
# void register_decomp_versions();
# GDScriptDecomp *create_decomp_for_commit(uint64_t p_commit_hash);
# Vector<Ref<GDScriptDecomp>> get_decomps_for_bytecode_ver(int bytecode_version, bool include_dev = false);
#
#
# struct GDScriptDecompVersion {
# 	uint64_t commit;
# 	String name;
#   int bytecode_version;
#   bool is_dev;
# };
#
# static const GDScriptDecompVersion decomp_versions[] = {
# // This contains a list of all the bytecode versions, in order, with their version, commit hash, date, and bytecode version, followed by a description derived from the "added_tokens", "added_functions", etc. fields>
# // for example:
# { 0xf3f05dc, "     4.0 dev (f3f05dc / 2020-02-13 / Bytecode version: 13) - removed `SYNC` and `SLAVE` tokens", 13, true }, // If it's a dev version, there's 5 leading spaces in the description, otherwise it's 0
# { 0x506df14, "     4.0 dev (506df14 / 2020-02-12 / Bytecode version: 13) - removed `decimals` function", 13, true },
# // etc...
# };

BYTECODE_CLASSDB_REGISTER = "//_BYTECODE_CLASSDB_REGISTER_"
BYTECODE_CASE_STATEMENTS = "//_BYTECODE_CASE_STATEMENTS_"
BYTECODE_HEADERS = "//_BYTECODE_HEADERS_"
BYTECODE_DECOMP_VERSIONS = "//_BYTECODE_DECOMP_VERSIONS_"
PRELUDE_REPLACE = "//_PRELUDE_"


def generate_bytecode_version_header(dir: Path, bytecode_classes: list[BytecodeClass]) -> None:
    new_dir = dir
    # get misc/bytecode_versions.h.inc
    code = ""
    with open(our_dir / "misc" / "bytecode_versions.h.inc", "r") as f:
        code = f.read()
    # ensure the directory exists
    if not new_dir.exists():
        new_dir.mkdir()
    new_file_h = new_dir / ("bytecode_versions.h")
    code = code.replace(PRELUDE_REPLACE, PRELUDE)
    header_str = ""
    for bytecode_class in bytecode_classes:
        header_str += f'#include "bytecode/{bytecode_class.file_stem}.h"\n'

    code = code.replace(BYTECODE_HEADERS, header_str)
    version_section = '\t{ 0xfffffff, "--- Please select bytecode version ---", 0, false },\n'
    # "4.3.0 release (77af6ca / 2024-02-09 / Bytecode version: 100) - initial version"
    ver_format = '\t{{ 0x{commit}, "{name}", {bytecode_version}, {is_dev}, "{ver}", "{max_ver}", 0x{parent} }},\n'
    name_format = "{ver} ({commit} / {date} / Bytecode version: {bytecode_version}) - {description}"
    for bytecode_class in bytecode_classes:
        name_tab = "\t" if bytecode_class.is_dev else ""
        line = ver_format.format(
            commit=bytecode_class.bytecode_rev,
            name=(
                name_tab
                + name_format.format(
                    ver=bytecode_class.engine_version,
                    commit=bytecode_class.bytecode_rev,
                    date=bytecode_class.date,
                    bytecode_version=bytecode_class.bytecode_version,
                    description=generate_bytecode_description_string(bytecode_class),
                )
            ),
            bytecode_version=bytecode_class.bytecode_version,
            is_dev=str(bytecode_class.is_dev).lower(),
            ver=bytecode_class.engine_version,
            max_ver=bytecode_class.max_engine_version if bytecode_class.max_engine_version else "",
            parent=bytecode_class.parent if bytecode_class.parent else 0,
        )
        version_section += line
    version_section += '\t{ 0x0000000, "-NULL-", 0, false },\n'
    code = code.replace(BYTECODE_DECOMP_VERSIONS, version_section)
    with open(new_file_h, "w") as f:
        f.write(code)


def generate_bytecode_versions_cpp(dir: Path, bytecode_classes: list[BytecodeClass]) -> None:
    new_dir = dir
    # ensure the directory exists
    code = ""
    with open(our_dir / "misc" / "bytecode_versions.cpp.inc", "r") as f:
        code = f.read()
    if not code:
        raise Exception("Failed to read bytecode_versions.cpp.inc")
    if not new_dir.exists():
        new_dir.mkdir()
    new_file_cpp = new_dir / ("bytecode_versions.cpp")
    code = code.replace(PRELUDE_REPLACE, PRELUDE)
    bytecode_classdb_register = ""
    for bytecode_class in bytecode_classes:
        bytecode_classdb_register += "\tClassDB::register_class<" + bytecode_class.class_name + ">();\n"
    code = code.replace(BYTECODE_CLASSDB_REGISTER, bytecode_classdb_register)
    bytecode_case_statements = ""
    for bytecode_class in bytecode_classes:
        bytecode_case_statements += (
            "\t\tcase 0x" + bytecode_class.bytecode_rev + ": return memnew(" + bytecode_class.class_name + ");\n"
        )
    code = code.replace(BYTECODE_CASE_STATEMENTS, bytecode_case_statements)

    with open(new_file_cpp, "w") as f:
        f.write(code)


bytecode_classes = []

# First, we need to get the bytecode directory
our_dir = Path(os.path.dirname(os.path.realpath(__file__)))
json_path = our_dir / "misc" / "bytecode_versions.json"
bytecode_dir = our_dir / "bytecode"

bytecode_classes = read_bytecode_json(json_path)
for bytecode_class in bytecode_classes:
    generate_class_cpp(bytecode_dir, bytecode_class)
    generate_class_header(bytecode_dir, bytecode_class)

generate_bytecode_version_header(bytecode_dir, bytecode_classes)
generate_bytecode_versions_cpp(bytecode_dir, bytecode_classes)
